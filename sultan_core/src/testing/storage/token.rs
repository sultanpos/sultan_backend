use crate::{
    domain::{
        Context,
        model::{token::Token, user::UserCreate},
    },
    storage::{
        SqliteUserRepository, TokenRepository, UserRepository, sqlite::SqliteTokenRepository,
    },
};
use chrono::{Duration, Utc};

pub async fn create_sqlite_user_and_token_repo()
-> (Context, SqliteTokenRepository, SqliteUserRepository) {
    let pool = super::init_sqlite_pool().await;
    (
        Context::new(),
        crate::storage::sqlite::token::SqliteTokenRepository::new(pool.clone()),
        crate::storage::sqlite::user::SqliteUserRepository::new(pool),
    )
}

/// Helper to create a test user (required due to foreign key constraint)
async fn create_test_user<R: UserRepository<Tx>, Tx>(user_repo: &R, ctx: &Context) -> i64 {
    let user_id = super::generate_test_id().await;
    let user = UserCreate {
        username: format!("token_test_user_{}", user_id),
        name: "Token Test User".to_string(),
        email: Some(format!("token_test_{}@example.com", user_id)),
        password: "hashed_password".to_string(),
        photo: None,
        pin: None,
        address: None,
        phone: None,
    };

    user_repo
        .create_user(ctx, user_id, &user)
        .await
        .expect("Failed to create test user");

    user_id
}

pub async fn token_test_save_and_get_token<Tx, U: UserRepository<Tx>>(
    ctx: &Context,
    token_repo: impl TokenRepository,
    user_repo: U,
) {
    // Create a user first (foreign key requirement)
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create a token
    let token_id = super::generate_test_id().await;
    let token_value = format!("test_token_{}", token_id);
    let expired_at = Utc::now() + Duration::hours(24);

    let token = Token {
        id: token_id,
        user_id,
        expired_at,
        token: token_value.clone(),
    };

    // Save the token
    token_repo
        .save(&ctx, &token)
        .await
        .expect("Failed to save token");

    // Retrieve the token by token value
    let fetched_token = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Failed to get token")
        .expect("Token not found");

    // ID is auto-generated by the database, so we just verify it exists
    assert!(fetched_token.id > 0);
    assert_eq!(fetched_token.user_id, user_id);
    assert_eq!(fetched_token.token, token_value);
    // Compare timestamps with some tolerance (seconds precision)
    assert!(
        (fetched_token.expired_at - expired_at).num_seconds().abs() < 2,
        "Expiration times don't match"
    );
}

pub async fn token_test_get_token_not_found(ctx: &Context, token_repo: impl TokenRepository) {
    let result = token_repo
        .get_by_token(&ctx, "non_existent_token")
        .await
        .expect("Query should succeed");

    assert!(result.is_none(), "Token should not be found");
}

pub async fn token_test_delete_token<Tx, U: UserRepository<Tx>>(
    ctx: &Context,
    token_repo: impl TokenRepository,
    user_repo: U,
) {
    // Create a user first
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create and save a token
    let token_id = super::generate_test_id().await;
    let token_value = format!("delete_test_token_{}", token_id);

    let token = Token {
        id: token_id,
        user_id,
        expired_at: Utc::now() + Duration::hours(24),
        token: token_value.clone(),
    };

    token_repo
        .save(&ctx, &token)
        .await
        .expect("Failed to save token");

    // Verify token exists and get the actual database-assigned ID
    let fetched = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Failed to get token")
        .expect("Token should exist before deletion");
    let actual_token_id = fetched.id;

    // Delete the token using the actual database-assigned ID
    token_repo
        .delete(&ctx, actual_token_id)
        .await
        .expect("Failed to delete token");

    // Verify token is deleted
    let fetched_after = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Query should succeed");
    assert!(fetched_after.is_none(), "Token should be deleted");
}

pub async fn token_test_delete_token_not_found(ctx: &Context, token_repo: impl TokenRepository) {
    let result = token_repo.delete(&ctx, 999999).await;

    assert!(result.is_err(), "Deleting non-existent token should fail");
    let err = result.unwrap_err();
    assert!(
        matches!(err, crate::domain::Error::NotFound(_)),
        "Error should be NotFound"
    );
}

pub async fn token_test_multiple_tokens_same_user<Tx, U: UserRepository<Tx>>(
    ctx: &Context,
    token_repo: impl TokenRepository,
    user_repo: U,
) {
    // Create a user
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create multiple tokens for the same user
    let token1_id = super::generate_test_id().await;
    let token1_value = format!("multi_token_1_{}", token1_id);
    let token1 = Token {
        id: token1_id,
        user_id,
        expired_at: Utc::now() + Duration::hours(24),
        token: token1_value.clone(),
    };

    let token2_id = super::generate_test_id().await;
    let token2_value = format!("multi_token_2_{}", token2_id);
    let token2 = Token {
        id: token2_id,
        user_id,
        expired_at: Utc::now() + Duration::hours(48),
        token: token2_value.clone(),
    };

    // Save both tokens
    token_repo
        .save(&ctx, &token1)
        .await
        .expect("Failed to save token 1");
    token_repo
        .save(&ctx, &token2)
        .await
        .expect("Failed to save token 2");

    // Verify both tokens can be retrieved and get their actual database-assigned IDs
    let fetched1 = token_repo
        .get_by_token(&ctx, &token1_value)
        .await
        .expect("Failed to get token 1")
        .expect("Token 1 not found");
    let actual_token1_id = fetched1.id;
    assert!(actual_token1_id > 0);

    let fetched2 = token_repo
        .get_by_token(&ctx, &token2_value)
        .await
        .expect("Failed to get token 2")
        .expect("Token 2 not found");
    let actual_token2_id = fetched2.id;
    assert!(actual_token2_id > 0);

    // Delete one token using actual database-assigned ID
    token_repo
        .delete(&ctx, actual_token1_id)
        .await
        .expect("Failed to delete token 1");

    // Verify token1 is deleted but token2 still exists
    let fetched1_after = token_repo
        .get_by_token(&ctx, &token1_value)
        .await
        .expect("Query should succeed");
    assert!(fetched1_after.is_none(), "Token 1 should be deleted");

    let fetched2_after = token_repo
        .get_by_token(&ctx, &token2_value)
        .await
        .expect("Query should succeed")
        .expect("Token 2 should still exist");
    assert_eq!(fetched2_after.id, actual_token2_id);
}

pub async fn token_test_token_with_expired_time<Tx, U: UserRepository<Tx>>(
    ctx: &Context,
    token_repo: impl TokenRepository,
    user_repo: U,
) {
    // Create a user
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create an already expired token
    let token_id = super::generate_test_id().await;
    let token_value = format!("expired_token_{}", token_id);
    let expired_at = Utc::now() - Duration::hours(1); // Expired 1 hour ago

    let token = Token {
        id: token_id,
        user_id,
        expired_at,
        token: token_value.clone(),
    };

    // Save the expired token (repository doesn't check expiration)
    token_repo
        .save(&ctx, &token)
        .await
        .expect("Failed to save expired token");

    // Retrieve the token - it should still be retrievable
    // (expiration check is application logic, not repository logic)
    let fetched = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Failed to get token")
        .expect("Token not found");

    // ID is auto-generated by the database, so we just verify it exists
    assert!(fetched.id > 0);
    assert!(fetched.expired_at < Utc::now(), "Token should be expired");
}
