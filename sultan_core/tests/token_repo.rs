mod common;

use chrono::{Duration, Utc};
use sultan_core::domain::Context;
use sultan_core::domain::model::token::Token;
use sultan_core::domain::model::user::UserCreate;
use sultan_core::snowflake::SnowflakeGenerator;
use sultan_core::storage::sqlite::token::SqliteTokenRepository;
use sultan_core::storage::sqlite::user::SqliteUserRepository;
use sultan_core::storage::token_repo::TokenRepository;
use sultan_core::storage::user_repo::UserRepository;

use common::init_sqlite_pool;

fn generate_test_id() -> i64 {
    thread_local! {
        static GENERATOR: SnowflakeGenerator = SnowflakeGenerator::new(1).unwrap();
    }
    GENERATOR.with(|g| g.generate().unwrap())
}

/// Helper to create a test user (required due to foreign key constraint)
async fn create_test_user(user_repo: &SqliteUserRepository, ctx: &Context) -> i64 {
    let user_id = generate_test_id();
    let user = UserCreate {
        username: format!("token_test_user_{}", user_id),
        name: "Token Test User".to_string(),
        email: Some(format!("token_test_{}@example.com", user_id)),
        password: "hashed_password".to_string(),
        photo: None,
        pin: None,
        address: None,
        phone: None,
    };

    user_repo
        .create_user(ctx, user_id, &user)
        .await
        .expect("Failed to create test user");

    user_id
}

#[tokio::test]
async fn test_save_and_get_token() {
    let pool = init_sqlite_pool().await;
    let token_repo = SqliteTokenRepository::new(pool.clone());
    let user_repo = SqliteUserRepository::new(pool);
    let ctx = Context::new();

    // Create a user first (foreign key requirement)
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create a token
    let token_id = generate_test_id();
    let token_value = format!("test_token_{}", token_id);
    let expired_at = Utc::now() + Duration::hours(24);

    let token = Token {
        id: token_id,
        user_id,
        expired_at,
        token: token_value.clone(),
    };

    // Save the token
    token_repo
        .save(&ctx, &token)
        .await
        .expect("Failed to save token");

    // Retrieve the token by token value
    let fetched_token = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Failed to get token")
        .expect("Token not found");

    // ID is auto-generated by the database, so we just verify it exists
    assert!(fetched_token.id > 0);
    assert_eq!(fetched_token.user_id, user_id);
    assert_eq!(fetched_token.token, token_value);
    // Compare timestamps with some tolerance (seconds precision)
    assert!(
        (fetched_token.expired_at - expired_at).num_seconds().abs() < 2,
        "Expiration times don't match"
    );
}

#[tokio::test]
async fn test_get_token_not_found() {
    let pool = init_sqlite_pool().await;
    let token_repo: SqliteTokenRepository = SqliteTokenRepository::new(pool);
    let ctx = Context::new();

    let result = token_repo
        .get_by_token(&ctx, "non_existent_token")
        .await
        .expect("Query should succeed");

    assert!(result.is_none(), "Token should not be found");
}

#[tokio::test]
async fn test_delete_token() {
    let pool = init_sqlite_pool().await;
    let token_repo = SqliteTokenRepository::new(pool.clone());
    let user_repo = SqliteUserRepository::new(pool);
    let ctx = Context::new();

    // Create a user first
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create and save a token
    let token_id = generate_test_id();
    let token_value = format!("delete_test_token_{}", token_id);

    let token = Token {
        id: token_id,
        user_id,
        expired_at: Utc::now() + Duration::hours(24),
        token: token_value.clone(),
    };

    token_repo
        .save(&ctx, &token)
        .await
        .expect("Failed to save token");

    // Verify token exists and get the actual database-assigned ID
    let fetched = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Failed to get token")
        .expect("Token should exist before deletion");
    let actual_token_id = fetched.id;

    // Delete the token using the actual database-assigned ID
    token_repo
        .delete(&ctx, actual_token_id)
        .await
        .expect("Failed to delete token");

    // Verify token is deleted
    let fetched_after = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Query should succeed");
    assert!(fetched_after.is_none(), "Token should be deleted");
}

#[tokio::test]
async fn test_delete_token_not_found() {
    let pool = init_sqlite_pool().await;
    let token_repo: SqliteTokenRepository = SqliteTokenRepository::new(pool);
    let ctx = Context::new();

    let result = token_repo.delete(&ctx, 999999).await;

    assert!(result.is_err(), "Deleting non-existent token should fail");
    let err = result.unwrap_err();
    assert!(
        matches!(err, sultan_core::domain::Error::NotFound(_)),
        "Error should be NotFound"
    );
}

#[tokio::test]
async fn test_multiple_tokens_same_user() {
    let pool = init_sqlite_pool().await;
    let token_repo = SqliteTokenRepository::new(pool.clone());
    let user_repo = SqliteUserRepository::new(pool);
    let ctx = Context::new();

    // Create a user
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create multiple tokens for the same user
    let token1_id = generate_test_id();
    let token1_value = format!("multi_token_1_{}", token1_id);
    let token1 = Token {
        id: token1_id,
        user_id,
        expired_at: Utc::now() + Duration::hours(24),
        token: token1_value.clone(),
    };

    let token2_id = generate_test_id();
    let token2_value = format!("multi_token_2_{}", token2_id);
    let token2 = Token {
        id: token2_id,
        user_id,
        expired_at: Utc::now() + Duration::hours(48),
        token: token2_value.clone(),
    };

    // Save both tokens
    token_repo
        .save(&ctx, &token1)
        .await
        .expect("Failed to save token 1");
    token_repo
        .save(&ctx, &token2)
        .await
        .expect("Failed to save token 2");

    // Verify both tokens can be retrieved and get their actual database-assigned IDs
    let fetched1 = token_repo
        .get_by_token(&ctx, &token1_value)
        .await
        .expect("Failed to get token 1")
        .expect("Token 1 not found");
    let actual_token1_id = fetched1.id;
    assert!(actual_token1_id > 0);

    let fetched2 = token_repo
        .get_by_token(&ctx, &token2_value)
        .await
        .expect("Failed to get token 2")
        .expect("Token 2 not found");
    let actual_token2_id = fetched2.id;
    assert!(actual_token2_id > 0);

    // Delete one token using actual database-assigned ID
    token_repo
        .delete(&ctx, actual_token1_id)
        .await
        .expect("Failed to delete token 1");

    // Verify token1 is deleted but token2 still exists
    let fetched1_after = token_repo
        .get_by_token(&ctx, &token1_value)
        .await
        .expect("Query should succeed");
    assert!(fetched1_after.is_none(), "Token 1 should be deleted");

    let fetched2_after = token_repo
        .get_by_token(&ctx, &token2_value)
        .await
        .expect("Query should succeed")
        .expect("Token 2 should still exist");
    assert_eq!(fetched2_after.id, actual_token2_id);
}

#[tokio::test]
async fn test_token_with_expired_time() {
    let pool = init_sqlite_pool().await;
    let token_repo = SqliteTokenRepository::new(pool.clone());
    let user_repo = SqliteUserRepository::new(pool);
    let ctx = Context::new();

    // Create a user
    let user_id = create_test_user(&user_repo, &ctx).await;

    // Create an already expired token
    let token_id = generate_test_id();
    let token_value = format!("expired_token_{}", token_id);
    let expired_at = Utc::now() - Duration::hours(1); // Expired 1 hour ago

    let token = Token {
        id: token_id,
        user_id,
        expired_at,
        token: token_value.clone(),
    };

    // Save the expired token (repository doesn't check expiration)
    token_repo
        .save(&ctx, &token)
        .await
        .expect("Failed to save expired token");

    // Retrieve the token - it should still be retrievable
    // (expiration check is application logic, not repository logic)
    let fetched = token_repo
        .get_by_token(&ctx, &token_value)
        .await
        .expect("Failed to get token")
        .expect("Token not found");

    // ID is auto-generated by the database, so we just verify it exists
    assert!(fetched.id > 0);
    assert!(fetched.expired_at < Utc::now(), "Token should be expired");
}
